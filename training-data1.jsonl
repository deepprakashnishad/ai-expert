{"Client":"Self","Project":"Calculator","Module":"calculator.js","Classname":"No classname","Function Name":"updateDisplay","Function Description":"This function updates results on calculator display","Code Snippet":"function updateDisplay(value) {\n    display.textContent = value;\n}","Version":1,"Path":"calculator.js"}
{"Client":"Self","Project":"Calculator","Module":"calculator.js","Classname":"No classname","Function Name":"handleNumberClick","Function Description":"This function handles when a number button is pressed. Depending on shouldResetDiaply global variable it would decide what action to perform. At last  updateDisplay function is called to update the display","Code Snippet":"function handleNumberClick(number) {\n    if (shouldResetDisplay) {\n        currentInput = number;\n        shouldResetDisplay = false;\n    } else {\n        currentInput = currentInput === '0' ? number : currentInput + number;\n    }\n    updateDisplay(currentInput);\n}","Version":1,"Path":"calculator.js"}
{"Client":"Self","Project":"Calculator","Module":"calculator.js","Classname":"No classname","Function Name":"handleOperatorClick","Function Description":"This function handles when a operator button is pressed.","Code Snippet":"function handleOperatorClick(newOperator) {\n    if (operator && currentInput && firstOperand) {\n        const result = evaluateOperation(parseFloat(firstOperand), parseFloat(currentInput), operator);\n        currentInput = result.toString();\n        updateDisplay(currentInput);\n        shouldResetDisplay = true;\n    } else {\n        firstOperand = currentInput;\n        shouldResetDisplay = true;\n    }\n    operator = newOperator;\n}","Version":1,"Path":"calculator.js"}
{"Client":"Self","Project":"Calculator","Module":"calculator.js","Classname":"No classname","Function Name":"handleEqualsClick","Function Description":"This function handles when equals button is clicked. It calculates final result depending on operator, firstOperand and currentInput","Code Snippet":"function handleEqualsClick() {\n    if (operator && currentInput && firstOperand) {\n        const result = evaluateOperation(parseFloat(firstOperand), parseFloat(currentInput), operator);\n        updateDisplay(result.toString());\n        currentInput = result.toString();\n        firstOperand = '';\n        operator = '';\n    }\n}","Version":1,"Path":"calculator.js"}
{"Client":"Self","Project":"Calculator","Module":"calculator.js","Classname":"No classname","Function Name":"evaluateOperation","Function Description":"This function performs operation based on operand that is selected. It is passed as third argument in the function","Code Snippet":"function evaluateOperation(num1, num2, op) {\n    switch (op) {\n        case '+':\n            return num1 + num2;\n        case '-':\n            return num1 - num2;\n        case '*':\n            return num1 * num2;\n        case '/':\n            if (num2 === 0) {\n                return 'Error';\n            }\n            return num1 / num2;\n        default:\n            return 'Error';\n    }\n}","Version":1,"Path":"calculator.js"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Classname":"No Classname","Function Name":"polls_list","Function Description":"This function generates a paginated list of polls, with options to filter by name, date, votes, and search terms. It handles pagination and preserves filter/search parameters in the URL.","Code Snippet":" @login_required()\ndef polls_list(request):\n    all_polls = Poll.objects.all()\n    search_term = ''\n    if 'name' in request.GET:\n        all_polls = all_polls.order_by('text')\n\n    if 'date' in request.GET:\n        all_polls = all_polls.order_by('pub_date')\n\n    if 'vote' in request.GET:\n        all_polls = all_polls.annotate(Count('vote')).order_by('vote__count')\n\n    if 'search' in request.GET:\n        search_term = request.GET['search']\n        all_polls = all_polls.filter(text__icontains=search_term)\n\n    paginator = Paginator(all_polls, 6)  # Show 6 contacts per page\n    page = request.GET.get('page')\n    polls = paginator.get_page(page)\n\n    get_dict_copy = request.GET.copy()\n    params = get_dict_copy.pop('page', True) and get_dict_copy.urlencode()\n\n    context = {\n        'polls': polls,\n        'params': params,\n        'search_term': search_term,\n    }\n    return render(request, 'polls/polls_list.html', context)","Version":1,"Path":"Views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Classname":"No Classname","Function Name":"list_by_users","Function Description":"This function displays polls owned by the logged-in user, fetching them from the database and paginating them to show 7 polls per page. Finally, it renders the list using the 'polls_list.html' template.","Code Snippet":"@login_required()\ndef list_by_user(request):\n    all_polls = Poll.objects.filter(owner=request.user)\n    paginator = Paginator(all_polls, 7)  # Show 7 contacts per page\n\n    page = request.GET.get('page')\n    polls = paginator.get_page(page)\n\n    context = {\n        'polls': polls,\n    }\n    return render(request, 'polls/polls_list.html', context)","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Classname":"No Classname","Function Name":"polls_add","Function Description":"This function lets authorized users create polls with choices, assigning ownership to themselves, and redirects to the polls list. If the user lacks permission, it displays a message denying access.","Code Snippet":"@login_required()\ndef polls_add(request):\n    if request.user.has_perm('polls.add_poll'):\n        if request.method == 'POST':\n            form = PollAddForm(request.POST)\n            if form.is_valid:\n                poll = form.save(commit=False)\n                poll.owner = request.user\n                poll.save()\n                Choice(\n                    poll=poll, choice_text=form.cleaned_data['choice1']).save()\n                Choice(\n                    poll=poll, choice_text=form.cleaned_data['choice2']).save()\n\n                messages.success(\n                    request, \"Poll & Choices added successfully.\", extra_tags='alert alert-success alert-dismissible fade show')\n\n                return redirect('polls:list')\n        else:\n            form = PollAddForm()\n        context = {\n            'form': form,\n        }\n        return render(request, 'polls/add_poll.html', context)\n    else:\n        return HttpResponse(\"Sorry but you don't have permission to do that!\")","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"polls_edit","Function Description":"This function allows the owner of a poll to edit its details. It checks if the logged-in user matches the poll's owner before displaying the edit form, and upon form submission, it updates the poll's information and redirects to the polls list page.","Code Snippet":"@login_required\ndef polls_edit(request, poll_id):\n    poll = get_object_or_404(Poll, pk=poll_id)\n    if request.user != poll.owner:\n        return redirect('home')\n\n    if request.method == 'POST':\n        form = EditPollForm(request.POST, instance=poll)\n        if form.is_valid:\n            form.save()\n            messages.success(request, \"Poll Updated successfully.\",\n                             extra_tags='alert alert-success alert-dismissible fade show')\n            return redirect(\"polls:list\")\n\n    else:\n        form = EditPollForm(instance=poll)\n\n    return render(request, \"polls/poll_edit.html\", {'form': form, 'poll': poll})","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"polls_delete","Function Description":"This function allows the owner of a poll to delete it. It verifies that the logged-in user matches the poll's owner before proceeding with deletion, and upon successful deletion, it displays a success message and redirects to the polls list page.","Code Snippet":"@login_required\ndef polls_delete(request, poll_id):\n    poll = get_object_or_404(Poll, pk=poll_id)\n    if request.user != poll.owner:\n        return redirect('home')\n    poll.delete()\n    messages.success(request, \"Poll Deleted successfully.\",\n                     extra_tags='alert alert-success alert-dismissible fade show')\n    return redirect(\"polls:list\")","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"add_choice","Function Description":"This function allows the owner of a poll to add choices to it. It checks ownership before displaying the choice addition form, saves the new choice to the corresponding poll upon submission, and redirects to the poll's edit page with a success message.","Code Snippet":"@login_required\ndef add_choice(request, poll_id):\n    poll = get_object_or_404(Poll, pk=poll_id)\n    if request.user != poll.owner:\n        return redirect('home')\n\n    if request.method == 'POST':\n        form = ChoiceAddForm(request.POST)\n        if form.is_valid:\n            new_choice = form.save(commit=False)\n            new_choice.poll = poll\n            new_choice.save()\n            messages.success(\n                request, \"Choice added successfully.\", extra_tags='alert alert-success alert-dismissible fade show')\n            return redirect('polls:edit', poll.id)\n    else:\n        form = ChoiceAddForm()\n    context = {\n        'form': form,\n    }\n    return render(request, 'polls/add_choice.html', context)","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"choice_edit","Function Description":"This function allows the owner of a choice to edit its details within a specific poll. It verifies ownership before displaying the edit form, updates the choice upon form submission, and redirects to the poll's edit page with a success message.","Code Snippet":"@login_required\ndef choice_edit(request, choice_id):\n    choice = get_object_or_404(Choice, pk=choice_id)\n    poll = get_object_or_404(Poll, pk=choice.poll.id)\n    if request.user != poll.owner:\n        return redirect('home')\n\n    if request.method == 'POST':\n        form = ChoiceAddForm(request.POST, instance=choice)\n        if form.is_valid:\n            new_choice = form.save(commit=False)\n            new_choice.poll = poll\n            new_choice.save()\n            messages.success(\n                request, \"Choice Updated successfully.\", extra_tags='alert alert-success alert-dismissible fade show')\n            return redirect('polls:edit', poll.id)\n    else:\n        form = ChoiceAddForm(instance=choice)\n    context = {\n        'form': form,\n        'edit_choice': True,\n        'choice': choice,\n    }\n    return render(request, 'polls/add_choice.html', context)","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"choice_delete","Function Description":"This function allows the owner of a choice to delete it within a specific poll. It checks ownership before proceeding with deletion, displays a success message upon completion, and redirects to the poll's edit page.","Code Snippet":"@login_required\ndef choice_delete(request, choice_id):\n    choice = get_object_or_404(Choice, pk=choice_id)\n    poll = get_object_or_404(Poll, pk=choice.poll.id)\n    if request.user != poll.owner:\n        return redirect('home')\n    choice.delete()\n    messages.success(\n        request, \"Choice Deleted successfully.\", extra_tags='alert alert-success alert-dismissible fade show')\n    return redirect('polls:edit', poll.id)","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"polls_detail","Function Description":"This function displays details about a specific poll. It checks if the poll is active and, if not, renders the poll's result page; otherwise, it renders the poll's detail page showing its question and choices for users to vote.","Code Snippet":"def poll_detail(request, poll_id):\n    poll = get_object_or_404(Poll, id=poll_id)\n\n    if not poll.active:\n        return render(request, 'polls/poll_result.html', {'poll': poll})\n    loop_count = poll.choice_set.count()\n    context = {\n        'poll': poll,\n        'loop_time': range(0, loop_count),\n    }\n    return render(request, 'polls/poll_detail.html', context)","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"polls_vote","Function Description":"This function handles user voting for a specific poll. It checks if the user can vote, saves their vote choice if provided, and redirects to the poll's result page. It also handles error cases such as already voted or no choice selected, providing appropriate messages and redirects.","Code Snippet":"@login_required\ndef poll_vote(request, poll_id):\n    poll = get_object_or_404(Poll, pk=poll_id)\n    choice_id = request.POST.get('choice')\n    if not poll.user_can_vote(request.user):\n        messages.error(\n            request, \"You already voted this poll!\", extra_tags='alert alert-warning alert-dismissible fade show')\n        return redirect(\"polls:list\")\n\n    if choice_id:\n        choice = Choice.objects.get(id=choice_id)\n        vote = Vote(user=request.user, poll=poll, choice=choice)\n        vote.save()\n        print(vote)\n        return render(request, 'polls/poll_result.html', {'poll': poll})\n    else:\n        messages.error(\n            request, \"No choice selected!\", extra_tags='alert alert-warning alert-dismissible fade show')\n        return redirect(\"polls:detail\", poll_id)\n    return render(request, 'polls/poll_result.html', {'poll': poll})","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/views.py","Function Name":"end_poll","Function Description":"This function allows the owner of a poll to end it, changing its active status to False. It renders the poll's result page to display the final results after ending the poll. If the poll is already inactive, it also renders the result page without changing anything.","Code Snippet":"@login_required\ndef end_poll(request, poll_id):\n    poll = get_object_or_404(Poll, pk=poll_id)\n    if request.user != poll.owner:\n        return redirect('home')\n\n    if poll.active is True:\n        poll.active = False\n        poll.save()\n        return render(request, 'polls/poll_result.html', {'poll': poll})\n    else:\n        return render(request, 'polls/poll_result.html', {'poll': poll})","Version":1,"Path":"views.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/admin.py","Classname":"ChoiceInline","Function Description":"This class defines an inline form for Choices within the Django admin interface. It specifies that each Poll in the admin interface should display a form for adding and editing associated Choices in a tabular format, with space for one extra Choice by default.","Code Snippet":"class ChoiceInline(admin.TabularInline):  # or admin.StackedInline for a different layout\n    model = Choice\n    extra = 1","Version":1,"Path":"admin.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/admin.py","Classname":"PollAdmin","Function Description":"This class configures the admin interface for the Poll model in Django. It specifies how Poll instances should be displayed in the admin interface, including fields to show in the list view, search and filter options, date hierarchy, and inline editing for associated Choice instances.","Code Snippet":"@admin.register(Poll)\nclass PollAdmin(admin.ModelAdmin):\n    list_display = [\"text\", \"owner\", \"pub_date\", \"active\", \"created_at\"]\n    search_fields = [\"text\", \"owner__username\"]\n    list_filter = [\"active\", 'created_at', 'pub_date']\n    date_hierarchy = \"pub_date\"\n    inlines = [ChoiceInline]","Version":1,"Path":"admin.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/admin.py","Classname":"ChoiceAdmin","Function Description":"This class defines the admin interface settings for the Choice model, specifying how Choice instances are displayed and managed. It includes fields for list display, search functionality, and an autocomplete field for linking choices to polls efficiently within the Django admin interface.","Code Snippet":"@admin.register(Choice)\nclass ChoiceAdmin(admin.ModelAdmin):\n    list_display = [\"choice_text\", \"poll\", 'created_at', 'updated_at']\n    search_fields = [\"choice_text\", \"poll__text\"]\n    autocomplete_fields = [\"poll\"]","Version":1,"Path":"admin.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/admin.py","Classname":"VoteAdmin","Function Description":"This class defines the admin interface settings for the Vote model, specifying how Vote instances are displayed and managed. It includes fields for list display, search functionality, and autocomplete fields for efficiently linking choices, polls, and users in the Django admin interface.","Code Snippet":"@admin.register(Vote)\nclass VoteAdmin(admin.ModelAdmin):\n    list_display = [\"choice\", \"poll\", \"user\", 'created_at']\n    search_fields = [\"choice__choice_text\", \"poll__text\", \"user__username\"]\n    autocomplete_fields = [\"choice\", \"poll\", \"user\"]","Version":1,"Path":"admin.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/forms.py","Classname":"PollAddForm","Function Description":"This class defines a form for adding Poll instances with two initial choices. It specifies fields for the poll's question and two initial choices, with specified character limits and widget attributes for styling in HTML forms. The form is designed to be user-friendly and compatible with the form-control Bootstrap class for styling.","Code Snippet":"class PollAddForm(forms.ModelForm):\n\n    choice1 = forms.CharField(label='Choice 1', max_length=100, min_length=1,\n                              widget=forms.TextInput(attrs={'class': 'form-control'}))\n    choice2 = forms.CharField(label='Choice 2', max_length=100, min_length=1,\n                              widget=forms.TextInput(attrs={'class': 'form-control'}))\n\n    class Meta:\n        model = Poll\n        fields = ['text', 'choice1', 'choice2']\n        widgets = {\n            'text': forms.Textarea(attrs={'class': 'form-control', 'rows': 5, 'cols': 20}),\n        }","Version":1,"Path":"forms.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/forms.py","Classname":"EditPollForm","Function Description":"this class defines a form used for editing poll questions. It limits the form to updating the text of the poll and styles it for a user-friendly experience in HTML forms.","Code Snippet":"class EditPollForm(forms.ModelForm):\n    class Meta:\n        model = Poll\n        fields = ['text', ]\n        widgets = {\n            'text': forms.Textarea(attrs={'class': 'form-control', 'rows': 5, 'cols': 20}),\n        }","Version":1,"Path":"forms.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/forms.py","Classname":"ChoiceAddForm","Function Description":"This class creates a form specifically for adding choices to a poll. It includes a field for the choice text and applies styling using the form-control class for consistency and user-friendliness in HTML forms.","Code Snippet":"class ChoiceAddForm(forms.ModelForm):\n    class Meta:\n        model = Choice\n        fields = ['choice_text', ]\n        widgets = {\n            'choice_text': forms.TextInput(attrs={'class': 'form-control', })\n        }","Version":1,"Path":"forms.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/models.py","Classname":"Poll","Function Name":"user_can_vote","Function Description":"This code defines a Django model for polls, including information about the owner, question text, publication date, activity status, and creation timestamp. It also includes methods to check if a user can vote, get the total vote count, and generate a result dictionary with vote percentages. The __str__ method provides a string representation of the poll's text.","Code Snippet":"class Poll(models.Model):\n    owner = models.ForeignKey(User, on_delete=models.CASCADE)\n    text = models.TextField()\n    pub_date = models.DateTimeField(default=timezone.now)\n    active = models.BooleanField(default=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def user_can_vote(self, user):\n        \"\"\" \n        Return False if user already voted\n        \"\"\"\n        user_votes = user.vote_set.all()\n        qs = user_votes.filter(poll=self)\n        if qs.exists():\n            return False\n        return True\n\n    @property\n    def get_vote_count(self):\n        return self.vote_set.count()\n\n    def get_result_dict(self):\n        res = []\n        for choice in self.choice_set.all():\n            d = {}\n            alert_class = ['primary', 'secondary', 'success',\n                           'danger', 'dark', 'warning', 'info']\n\n            d['alert_class'] = secrets.choice(alert_class)\n            d['text'] = choice.choice_text\n            d['num_votes'] = choice.get_vote_count\n            if not self.get_vote_count:\n                d['percentage'] = 0\n            else:\n                d['percentage'] = (choice.get_vote_count /\n                                   self.get_vote_count)*100\n\n            res.append(d)\n        return res\n\n    def __str__(self):\n        return self.text","Version":1,"Path":"models.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/models.py","Classname":"Choice","Function Name":"get_vote_count","Function Description":"This code defines a Django model Choice representing individual choices within a poll. Each choice is associated with a specific poll and includes text, creation time, and last update time.\n\nThe get_vote_count property calculates and returns the total number of votes received by that choice. The __str__ method creates a concise string representation showing truncated versions of the associated poll's text and the choice text for easier identification and debugging.","Code Snippet":"class Choice(models.Model):\n    poll = models.ForeignKey(Poll, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=255)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    @property\n    def get_vote_count(self):\n        return self.vote_set.count()\n\n    def __str__(self):\n        return f\"{self.poll.text[:25]} - {self.choice_text[:25]}\"","Version":1,"Path":"models.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/models.py","Classname":"Vote","Function Description":"This model Vote tracks user votes in polls by associating them with specific users, polls, and choices. The __str__ method creates a concise string representation showing truncated versions of the poll's text, choice text, and the voter's username for easy identification and management.","Code Snippet":"class Vote(models.Model):\n    user = models.ForeignKey(User, on_delete=models.CASCADE)\n    poll = models.ForeignKey(Poll, on_delete=models.CASCADE)\n    choice = models.ForeignKey(Choice, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    def __str__(self):\n        return f'{self.poll.text[:15]} - {self.choice.choice_text[:15]} - {self.user.username}'","Version":1,"Path":"models.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/tests.py","Classname":"PollModelTest","Function Name":"test_user_can_vote","Function Description":"This PollModelTest class tests the user_can_vote method of the Poll model. It creates a user and a poll, checks if the user can vote on the poll initially, simulates a vote, and verifies that the user cannot vote again after voting once. This ensures the voting eligibility logic in the user_can_vote method is functioning as expected.","Code Snippet":"class PollModelTest(TestCase):\n    def test_user_can_vote(self):\n        user = User.objects.create_user('john')\n        poll = Poll.objects.create(owner=user)\n        self.assertTrue(poll.user_can_vote(user))\n\n        choice = poll.choice_set.create(choice_text='pizza')\n        Vote.objects.create(user=user, poll=poll, choice=choice)\n        self.assertFalse(poll.user_can_vote(user))","Version":1,"Path":"tests.py"}
{"Client":"Self","Project":"MyVotingApp","Module":"polls/tests.py","Classname":"PollViewTest","Function Description":"This PollViewTest class tests the views and functionalities related to user interactions on the website.","Code Snippet":"class PollViewTest(TestCase):\n    def test_home(self):\n        response = self.client.get('/')\n        self.assertEqual(response.status_code, 200)\n\n    def test_login(self):\n        User.objects.create_user(username='john', password='rambo')\n        response = self.client.post(\n            '/accounts/login/', {'username': 'john', 'password': 'rambo'}\n        )\n        self.assertRedirects(response, '/')\n\n    def test_register(self):\n        response = self.client.post(\n            '/accounts/register/',\n            {\n                'username': 'johny',\n                'password1': 'rambo',\n                'password2': 'rambo',\n                'email': 'johny.rambo@usarmy.gov',\n            },\n        )\n        self.assertRedirects(response, '/accounts/login/')\n        # assert that user got actually created in the backend\n        self.assertIsNotNone(authenticate(username='johny', password='rambo'))","Version":1,"Path":"tests.py"}